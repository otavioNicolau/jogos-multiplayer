<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake ‚Äî Endless + Multiplayer (cliente)</title>
  <style>
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;background:#0b1020;color:#fff;font-family:system-ui,Arial}
    .wrap{display:grid;gap:10px;place-items:center;max-width:1500px;padding:10px}
    .stage{display:grid;grid-template-columns:auto 260px;gap:12px;align-items:start}
    canvas.main{background:#0f0f17;border:2px solid #2a2a2a;border-radius:8px;image-rendering: pixelated}
    canvas.mini{background:#0b0e25;border:2px solid #2a2a2a;border-radius:8px;image-rendering: pixelated}
    .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    input,button{background:#1b1f3a;color:#fff;border:1px solid #2f3568;border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer}
    label{font-size:12px;color:#a7b}
    .hud{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
    .card{background:#121534;border:1px solid #2f3568;border-radius:10px;padding:8px 12px}
    .pill{padding:2px 8px;border-radius:999px;background:#1c2050;border:1px solid #2b3174;color:#cfe}
    #msg{min-height:1.2em;color:#9fd}
    .touch{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;width:220px;margin-top:8px}
    .touch .ghost{visibility:hidden}
    .sidebar{display:grid;gap:10px}
    .legend{background:#121534;border:1px solid #2f3568;border-radius:10px;padding:8px 12px;font-size:12px;line-height:1.5}
    .legend .tag{display:inline-flex;align-items:center;gap:6px;margin-right:8px;margin-bottom:6px}
    .legend .chip{display:inline-block;width:14px;height:14px;border-radius:3px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üêç Cobrinha ‚Äî Tela sem fim + Multiplayer (cliente) ‚Äî N√≠vel 3 (Tela Maior)</h1>

    <div class="row">
      <div class="card">
        <div><label>Servidor WS</label></div>
        <input id="wsurl" size="28" value="ws://localhost:8080" />
      </div>
      <div class="card">
        <div><label>Seu nome</label></div>
        <input id="playername" size="14" placeholder="Jogador" />
      </div>
      <button id="connect">Conectar</button>
      <button id="start" disabled>Iniciar</button>
      <button id="pause" disabled>Pausar</button>
      <button id="reset" disabled>Desistir</button>
      <button id="fullscreen">Tela Cheia</button>
    </div>

    <div class="hud">
      <div class="pill">Pontos: <b id="score">0</b></div>
      <div class="pill">Jogadores: <b id="pcount">0</b></div>
      <div class="pill">Ping: <b id="ping">--</b> ms</div>
      <div class="pill">Mundo: <b id="world">--</b></div>
    </div>

    <div class="stage">
      <canvas id="c" class="main" width="1200" height="800" aria-label="tabuleiro"></canvas>
      <div class="sidebar">
        <canvas id="mini" class="mini" width="240" height="240" aria-label="minimapa"></canvas>
        <div class="legend">
          <div><strong>Mini-mapa</strong></div>
          <div class="tag"><span class="chip" style="background:#ffffff"></span> Voc√™</div>
          <div class="tag"><span class="chip" style="background:#7c5cff"></span> Outros jogadores</div>
          <div class="tag"><span class="chip" style="background:#ffcc00"></span> Frutas</div>
          <div style="margin-top:8px;color:#9bb">Zoom baseado no tamanho do mundo.</div>
        </div>
      </div>
    </div>

    <div id="msg"></div>
    <small>Controles: setas / WASD ‚Äî Espa√ßo: Pausa ‚Ä¢ Mundo infinito (wrap). Com mini-mapa, texturas e sprites.</small>

    <div class="touch">
      <button data-dir="up">‚¨ÜÔ∏è</button>
      <div class="ghost"></div>
      <button data-dir="right">‚û°Ô∏è</button>
      <button data-dir="left">‚¨ÖÔ∏è</button>
      <div class="ghost"></div>
      <button data-dir="down">‚¨áÔ∏è</button>
    </div>
  </div>

  <script>
    // ===== util RNG est√°vel para decora√ß√£o =====
    function hash32(x, y){ let h=(x*374761393 + y*668265263)|0; h^=h<<13; h^=h>>>17; h^=h<<5; return (h>>>0)/4294967296; }

    // ===== CLIENTE =====
    const cvs = document.getElementById('c');
    const ctx = cvs.getContext('2d');
    const mini = document.getElementById('mini');
    const mtx = mini.getContext('2d');

    const scoreEl = document.getElementById('score');
    const pcountEl= document.getElementById('pcount');
    const pingEl  = document.getElementById('ping');
    const worldEl = document.getElementById('world');
    const msgEl   = document.getElementById('msg');

    const wsUrlEl = document.getElementById('wsurl');
    const nameEl  = document.getElementById('playername');
    const btnConn = document.getElementById('connect');
    const btnStart= document.getElementById('start');
    const btnPause= document.getElementById('pause');
    const btnReset= document.getElementById('reset');
    const btnFS   = document.getElementById('fullscreen');

    const touchBtns = document.querySelectorAll('.touch [data-dir]');

    let ws, myId = null, connected = false, running = false;

    // estado
    let WORLD = {w:60, h:60};
    const CELL = 24; // px por c√©lula
    let players = {}; let apples = [];

    // ===== sprites offscreen =====
    const sprites = { groundTile: makeGroundTile(), fruits: makeFruitSprites() };

    function makeGroundTile(){
      const s=24, off=document.createElement('canvas'); off.width=off.height=s; const g=off.getContext('2d');
      g.fillStyle='#0f1430'; g.fillRect(0,0,s,s);
      g.strokeStyle='rgba(255,255,255,0.05)'; g.lineWidth=1;
      g.beginPath(); g.moveTo(-s,s/2); g.lineTo(s*2,s/2); g.stroke();
      g.beginPath(); g.moveTo(0,0); g.lineTo(s,s); g.stroke();
      g.beginPath(); g.moveTo(0,s); g.lineTo(s,0); g.stroke();
      return off;
    }
    function makeFruitSprites(){
      const types=['apple','banana','cherry','pear']; const map={}; types.forEach(t=> map[t]=drawFruit(t)); return map;
      function drawFruit(type){
        const s=22, off=document.createElement('canvas'); off.width=off.height=s; const g=off.getContext('2d');
        g.clearRect(0,0,s,s);
        if(type==='apple'){
          g.fillStyle='#ff3b3b'; g.beginPath(); g.arc(s/2, s/2+1, 8, 0, Math.PI*2); g.fill();
          g.fillStyle='rgba(255,255,255,.3)'; g.beginPath(); g.arc(s/2-3, s/2-1, 3, 0, Math.PI*2); g.fill();
          g.fillStyle='#6d4c41'; g.fillRect(s/2-1, s/2-10, 2, 5);
          g.fillStyle='#20e3b2'; g.beginPath(); g.ellipse(s/2+5, s/2-6, 5, 3, -0.6, 0, Math.PI*2); g.fill();
        } else if(type==='banana'){
          g.strokeStyle='#ffd84d'; g.lineWidth=5; g.beginPath(); g.arc(s/2, s/2+3, 9, 0.2, 2.7); g.stroke();
          g.strokeStyle='#e6c43f'; g.lineWidth=2; g.beginPath(); g.arc(s/2, s/2+3, 9, 0.5, 2.4); g.stroke();
        } else if(type==='cherry'){
          g.fillStyle='#ff4d6d'; g.beginPath(); g.arc(s/2-4, s/2+2, 6, 0, Math.PI*2); g.fill();
          g.beginPath(); g.arc(s/2+4, s/2+2, 6, 0, Math.PI*2); g.fill();
          g.strokeStyle='#6d4c41'; g.lineWidth=2; g.beginPath(); g.moveTo(s/2-4, s/2-5); g.bezierCurveTo(s/2, s/2-12, s/2, s/2-12, s/2+4, s/2-5); g.stroke();
          g.fillStyle='#20e3b2'; g.beginPath(); g.ellipse(s/2, s/2-9, 5, 3, 0, 0, Math.PI*2); g.fill();
        } else if(type==='pear'){
          g.fillStyle='#7ed957'; g.beginPath(); g.moveTo(s/2, s/2-6); g.bezierCurveTo(s/2+9, s/2-10, s/2+9, s/2+8, s/2, s/2+8); g.bezierCurveTo(s/2-9, s/2+8, s/2-9, s/2-10, s/2, s/2-6); g.fill();
          g.fillStyle='#20e3b2'; g.beginPath(); g.ellipse(s/2+4, s/2-8, 5, 3, 0.4, 0, Math.PI*2); g.fill();
          g.fillStyle='#6d4c41'; g.fillRect(s/2-1, s/2-12, 2, 5);
        }
        return off;
      }
    }

    // ===== mini-mapa =====
    function drawMiniMap(){
      mtx.clearRect(0,0,mini.width, mini.height);
      mtx.fillStyle='#0b0e25'; mtx.fillRect(0,0,mini.width, mini.height);
      const sx=mini.width/WORLD.w, sy=mini.height/WORLD.h;
      mtx.globalAlpha=0.2; mtx.fillStyle='#445';
      for(let y=0;y<WORLD.h;y+=4){ for(let x=0;x<WORLD.w;x+=4){ if(hash32(x,y)>0.75) mtx.fillRect(Math.floor(x*sx),Math.floor(y*sy),Math.ceil(2*sx),Math.ceil(2*sy)); }}
      mtx.globalAlpha=1;
      mtx.fillStyle='#ffcc00'; apples.forEach(a=> mtx.fillRect(a.x*sx,a.y*sy, Math.max(1,sx), Math.max(1,sy)));
      Object.entries(players).forEach(([id,p])=>{ mtx.fillStyle = id===myId?'#ffffff':'#7c5cff'; mtx.fillRect(p.x*sx,p.y*sy, Math.max(1,sx+0.5), Math.max(1,sy+0.5)); });
      const cx=mini.width/2, cy=mini.height/2; mtx.strokeStyle='rgba(255,255,255,.25)';
      mtx.beginPath(); mtx.moveTo(cx-6,cy); mtx.lineTo(cx+6,cy); mtx.stroke();
      mtx.beginPath(); mtx.moveTo(cx,cy-6); mtx.lineTo(cx,cy+6); mtx.stroke();
    }

    // ===== c√¢mera com wrap =====
    function worldToScreen(x,y){
      const me = players[myId]; const vx = me? me.x : 0, vy = me? me.y : 0;
      const sx = Math.floor(cvs.width/2/CELL); const sy = Math.floor(cvs.height/2/CELL);
      const dx = ((x - vx + WORLD.w*1.5) % WORLD.w) - WORLD.w/2;
      const dy = ((y - vy + WORLD.h*1.5) % WORLD.h) - WORLD.h/2;
      return {px:(sx+dx)*CELL, py:(sy+dy)*CELL};
    }

    function drawGround(){
      const cols = Math.ceil(cvs.width / CELL) + 2;
      const rows = Math.ceil(cvs.height / CELL) + 2;
      const me = players[myId] || {x:0,y:0};
      const startX = Math.floor(me.x - cols/2);
      const startY = Math.floor(me.y - rows/2);
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          let wx=(startX+c+WORLD.w)%WORLD.w; let wy=(startY+r+WORLD.h)%WORLD.h;
          const {px,py}=worldToScreen(wx,wy);
          ctx.drawImage(sprites.groundTile, Math.round(px), Math.round(py), CELL, CELL);
          const rnd=hash32(wx,wy);
          if(rnd>0.92){ ctx.fillStyle='rgba(255,255,255,.06)'; ctx.fillRect(Math.round(px+8), Math.round(py+10), 4, 4); }
          else if(rnd<0.06){ ctx.fillStyle='rgba(32,227,178,.12)'; ctx.fillRect(Math.round(px+5), Math.round(py+6), 3, 6); ctx.fillRect(Math.round(px+11), Math.round(py+7), 3, 5); }
        }
      }
    }

    function fruitTypeFromId(id){ let h=0; for(let i=0;i<id.length;i++){ h=(h*31+id.charCodeAt(i))>>>0;} const types=Object.keys(sprites.fruits); return types[h%types.length]; }
    function drawFruit(x,y,id){ const type=fruitTypeFromId(id||'apple'); const spr=sprites.fruits[type]||sprites.fruits.apple; const {px,py}=worldToScreen(x,y); ctx.drawImage(spr, Math.round(px+1), Math.round(py+1), CELL-2, CELL-2); }

    function drawSnake(p){ p.body.forEach((seg,i)=>{ const {px,py}=worldToScreen(seg.x,seg.y); if(i===0){ ctx.fillStyle='#ffffff'; ctx.fillRect(Math.round(px),Math.round(py),CELL-1,CELL-1); ctx.fillStyle='rgba(0,0,0,.15)'; ctx.fillRect(Math.round(px+CELL-6), Math.round(py+4), 2, 2);} else { ctx.fillStyle=p.color; ctx.fillRect(Math.round(px),Math.round(py),CELL-1,CELL-1);} }); }

    function render(){ ctx.fillStyle='#0d1030'; ctx.fillRect(0,0,cvs.width,cvs.height); drawGround(); apples.forEach(a=> drawFruit(a.x,a.y,a.id)); Object.values(players).forEach(drawSnake); drawMiniMap(); }

    // ===== input -> servidor =====
    let lastDir={x:1,y:0};
    function sendDir(nx,ny){ if(!connected) return; if(lastDir && nx===-lastDir.x && ny===-lastDir.y) return; lastDir={x:nx,y:ny}; ws.send(JSON.stringify({type:'dir', x:nx, y:ny})); }
    window.addEventListener('keydown', (e)=>{ const k=e.key.toLowerCase(); if(["arrowup","w"].includes(k)) sendDir(0,-1); else if(["arrowdown","s"].includes(k)) sendDir(0,1); else if(["arrowleft","a"].includes(k)) sendDir(-1,0); else if(["arrowright","d"].includes(k)) sendDir(1,0); else if(k===' '){ togglePause(); }});
    touchBtns.forEach(b=> b.addEventListener('click', ()=>{ const d=b.dataset.dir; if(d==='up')sendDir(0,-1); if(d==='down')sendDir(0,1); if(d==='left')sendDir(-1,0); if(d==='right')sendDir(1,0); }));

    // ===== render loop =====
    function loop(){ requestAnimationFrame(loop); render(); }
    requestAnimationFrame(loop);

    // ===== WebSocket =====
    const msg = (t)=> msgEl.textContent=t;
    btnConn.addEventListener('click', ()=>{ if(connected){ ws.close(); return; } connect(); });
    btnStart.addEventListener('click', ()=>{ if(connected){ ws.send(JSON.stringify({type:'start'})); running=true; } });
    btnPause.addEventListener('click', ()=> togglePause());
    btnReset.addEventListener('click', ()=>{ if(connected){ ws.send(JSON.stringify({type:'reset'})); } });
    btnFS.addEventListener('click', ()=>{ if(document.fullscreenElement){ document.exitFullscreen(); } else { document.documentElement.requestFullscreen(); } });

    function togglePause(){ if(!connected) return; running=!running; ws.send(JSON.stringify({type: running?'resume':'pause'})); }

    function connect(){
      const url=wsUrlEl.value.trim(); ws=new WebSocket(url); msg('Conectando‚Ä¶');
      ws.onopen = ()=>{ connected=true; btnConn.textContent='Desconectar'; btnStart.disabled=false; btnPause.disabled=false; btnReset.disabled=false; const name=nameEl.value.trim()||`Player-${Math.floor(Math.random()*1000)}`; ws.send(JSON.stringify({type:'hello', name})); ping(); };
      ws.onclose=()=>{ connected=false; btnConn.textContent='Conectar'; msg('Desconectado.'); };
      ws.onerror=()=> msg('Erro de conex√£o. Confira o servidor.');
      ws.onmessage=(ev)=>{ const data=JSON.parse(ev.data); if(data.type==='init'){ myId=data.id; WORLD=data.world; apples=data.apples; players=data.players; worldEl.textContent=`${WORLD.w}x${WORLD.h}`; updateHUD(); fitCanvas(); } else if(data.type==='state'){ apples=data.apples; players=data.players; updateHUD(); } else if(data.type==='msg'){ msg(data.text); } else if(data.type==='pong'){ const now=performance.now(); pingEl.textContent=Math.round(now-data.t); } };
    }

    function updateHUD(){ pcountEl.textContent=Object.keys(players).length; const me=players[myId]; scoreEl.textContent= me? me.score : 0; }

    function ping(){ if(!connected) return; ws.send(JSON.stringify({type:'ping', t: performance.now()})); setTimeout(ping, 1000); }

    // ===== ajuste autom√°tico de tamanho do canvas =====
    function fitCanvas(){
      const SIDE=260, MARG=60; // largura da sidebar + margens
      let w = Math.min(1400, window.innerWidth - SIDE - MARG);
      let h = Math.min(900, window.innerHeight - 220); // desconta header/controles
      w = Math.max(600, w); h = Math.max(420, h);
      // ajusta para m√∫ltiplos do tamanho da c√©lula
      w = Math.floor(w / CELL) * CELL;
      h = Math.floor(h / CELL) * CELL;
      cvs.width = w; cvs.height = h;
      // mini-mapa escala junto
      const miniSize = Math.max(180, Math.min(280, Math.floor(Math.min(w,h)/4)));
      mini.width = mini.height = miniSize;
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();
  </script>
</body>
</html>
